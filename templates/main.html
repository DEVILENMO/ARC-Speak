{% extends "base.html" %}

{% block head %}
<style>
.voice-user-card {
    border: 2px solid #4F545C; /* 深灰色边框 */
    background-color: #36393F; /* 深灰色背景 */
    padding: 10px;
    margin: 5px;
    border-radius: 5px;
    display: flex;
    align-items: center;
    transition: border-color 0.3s ease, background-color 0.3s ease; /* 过渡效果 */
}

.voice-user-card.speaking {
    border-color: #7289DA; /* 紫色边框 */
    background-color: #40444B; /* 略浅的紫色调背景 */
}

.voice-user-card .user-avatar-placeholder {
    width: 30px;
    height: 30px;
    background-color: #7289DA;
    color: white;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    margin-right: 10px;
    font-weight: bold;
}

.voice-user-card .username {
    color: #FFFFFF;
}

.voice-user-card .mic-status {
    margin-left: auto; /* 将麦克风状态推到右侧 */
    /* 可以在这里添加图标等 */
}
</style>
<!-- WebRTC代码，只在需要时加载 -->
{% if current_channel and current_channel.channel_type == 'voice' %}
<script src="{{ url_for('static', filename='js/webrtc.js') }}"></script>
{% endif %}
{% endblock %}

{% block content %}
<!-- 左侧边栏：频道列表 -->
<div class="sidebar">
    <div class="user-avatar-container" onclick="location.href='{{ url_for('settings') }}';">
        {% if current_user.avatar_url %}
            <img src="{{ current_user.avatar_url }}" alt="User Avatar" class="avatar-image">
        {% else %}
            <div class="avatar-placeholder">
                <span class="avatar-text">{{ current_user.username[0].upper() }}</span>
            </div>
        {% endif %}
        <span class="username-display">{{ current_user.username }}</span>
    </div>
    
    <!-- 文字频道 -->
    <div class="channel-list">
        <div class="channel-header">文字频道</div>
        {% for channel in text_channels %}
        <div class="channel {% if current_channel and current_channel.id == channel.id %}current-channel{% endif %}" 
             onclick="location.href='{{ url_for('channel', channel_id=channel.id) }}';">
            {% if channel.is_private %}🔒 {% endif %}# {{ channel.name }}
        </div>
        {% endfor %}
    </div>
    
    <!-- 语音频道 -->
    <div class="channel-list">
        <div class="channel-header">语音频道</div>
        {% for channel in voice_channels %}
        <div class="channel {% if current_channel and current_channel.id == channel.id %}current-channel{% endif %}" 
             onclick="location.href='{{ url_for('channel', channel_id=channel.id) }}';">
            {% if channel.is_private %}🔒 {% endif %}🔊 {{ channel.name }}
        </div>
        {% endfor %}
    </div>
    
    {% if current_user.is_admin %}
    <div style="margin-top: 20px;">
        <button onclick="location.href='{{ url_for('create_channel') }}';" 
                style="width: 100%; padding: 8px; background-color: #7289da; color: white; border: none; border-radius: 3px; cursor: pointer;">
            创建新频道
        </button>
    </div>
    {% endif %}
    
    <div style="margin-top: 10px;">
        <button onclick="location.href='{{ url_for('logout') }}';" 
                style="width: 100%; padding: 8px; background-color: #f04747; color: white; border: none; border-radius: 3px; cursor: pointer;">
            登出
        </button>
    </div>
</div>

<!-- 主内容区 -->
<div class="main-content">
    {% if current_channel %}
        {% if current_channel.channel_type == 'text' %}
            <!-- 文字频道内容 -->
            <div class="chat-container" id="chat-container">
                {% if messages %}
                    {% for message in messages %}
                    <div class="message" id="message-{{ message.id }}">
                        <div class="message-avatar">
                            {% if message.user.avatar_url %}
                                <img src="{{ message.user.avatar_url }}" alt="{{ message.user.username }} avatar" class="avatar-image-sm">
                            {% else %}
                                <div class="avatar-placeholder-sm">
                                    <span class="avatar-text-sm">{{ message.user.username[0].upper() }}</span>
                                </div>
                            {% endif %}
                        </div>
                        <div class="message-content-container">
                            <span class="username">{{ message.user.username }}</span>
                            <span class="timestamp">{{ message.timestamp.strftime('%H:%M:%S') }}</span>
                            <div class="content">{{ message.content }}</div>
                        </div>
                    </div>
                    {% endfor %}
                {% else %}
                    <div style="text-align: center; margin-top: 20px; color: #8e9297;">
                        没有消息。发送第一条消息开始聊天吧！
                    </div>
                {% endif %}
            </div>
            <div class="message-input">
                <input type="text" id="message-input" placeholder="发送消息到 #{{ current_channel.name }}">
                <button onclick="sendMessage()">发送</button>
            </div>
        {% else %}
            <!-- 语音频道内容 -->
            <div class="chat-container">
                <div style="text-align: center; margin: 20px 0;">
                    <h2>语音频道: {{ current_channel.name }}</h2>
                </div>
                
                <div id="users-container">
                    {% if active_users %}
                        {% for session in active_users %}
                        <div class="voice-user-card" id="voice-user-{{ session.user.id }}">
                            <div class="user-avatar-placeholder">
                                <span>{{ session.user.username[0].upper() }}</span>
                            </div>
                            <span class="username">{{ session.user.username }}</span>
                            <div class="mic-status" id="mic-status-{{ session.user.id }}">
                                <!-- 麦克风状态指示 (例如图标) 将通过JS更新 -->
                            </div>
                        </div>
                        {% endfor %}
                    {% else %}
                        <div style="text-align: center; color: #8e9297;">
                            没有人在此频道中。
                        </div>
                    {% endif %}
                </div>
                
                <!-- 用于语音输出的隐藏音频元素 -->
                <div id="remote-audio-container" style="display: none;"></div>
            </div>
            
            <!-- 语音控制 -->
            <div class="voice-controls">
                <button id="join-voice-btn" onclick="joinVoiceChannel({{ current_channel.id if current_channel else 'null' }})">加入语音</button>
                <button id="leave-voice-btn" onclick="leaveVoiceChannel()" style="display: none;">离开语音</button>
                <button id="mute-btn" onclick="toggleMute()" class="mute" style="display: none;">静音</button>
            </div>
        {% endif %}
    {% else %}
        <!-- 未选择频道时的默认内容 -->
        <div style="display: flex; justify-content: center; align-items: center; height: 100%;">
            <div style="text-align: center; color: #8e9297;">
                <h2>欢迎使用语音聊天服务</h2>
                <p>请从左侧选择一个频道开始聊天</p>
            </div>
        </div>
    {% endif %}
</div>

<!-- 右侧边栏：用户列表 -->
<div class="user-list">
    <div class="channel-header">在线用户</div>
    <div id="online-users">
        <!-- 用户会通过WebSocket动态添加 -->
        <div class="user">
            <div class="user-status online"></div>
            <span>{{ current_user.username }} (你)</span>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
    const socket = io(); // Socket.IO 客户端初始化
    let currentChannelId = null; // 用于存储当前频道ID
    let currentUserId = null;    // 用于存储当前用户ID

    {% if current_channel %}
        currentChannelId = {{ current_channel.id }};
    {% endif %}
    {% if current_user %}
        currentUserId = {{ current_user.id }};
    {% endif %}

    // 当socket连接成功并且获取到用户ID后，初始化WebRTC
    socket.on('connect', function() {
        if (currentUserId && typeof initializeWebRTC === 'function') {
            initializeWebRTC(socket, currentUserId);
        }
        
        {% if current_channel %}
            {% if current_channel.channel_type == 'text' %}
                // 文字频道加入逻辑
                socket.emit('join_text_channel', {channel_id: currentChannelId});
                const chatContainer = document.getElementById('chat-container');
                if (chatContainer) chatContainer.scrollTop = chatContainer.scrollHeight;
            {% else %}
                // 语音频道特有逻辑可以在 joinVoiceChannel 中处理，
                // 或者在这里进行一些初始设置（如果需要的话）
            {% endif %}
        {% endif %}
    });

    {% if current_channel and current_channel.channel_type == 'voice' %}
        // 移除之前在 main.html 中添加的语音检测逻辑
        // let localAudioAnalyser = null;
        // let localAudioDataArray = null;
        // const SPEAKING_THRESHOLD = 5;
        // let currentUserSpeaking = false;
        // let speakingDetectionInterval = null;

        // function setupLocalMicrophoneDetection() { ... } // 移除
        // function detectCurrentUserSpeaking() { ... } // 移除
    {% endif %}

    // 全局的 inVoiceChannel 状态
    let inVoiceChannel = false;
    let localStreamReady = false; // <--- 新增标志位
    let pendingPeerConnectionUserIds = []; // <--- 存储等待处理的用户ID
            
    function processPendingPeerConnections() {
        if (localStreamReady && pendingPeerConnectionUserIds.length > 0) {
            console.debug("[MainHTML] Processing pending peer connections for users:", pendingPeerConnectionUserIds);
            pendingPeerConnectionUserIds.forEach(userId => {
                if (userId != currentUserId && typeof createPeerConnection === 'function' && typeof negotiateConnection === 'function') {
                    console.debug("[MainHTML] Creating peer connection for pending user:", userId);
                    createPeerConnection(userId); 
                    negotiateConnection(userId);
                }
            });
            pendingPeerConnectionUserIds = []; // 清空队列
        }
    }

    function joinVoiceChannel(channelId) {
        if (!socket || !currentUserId) {
            console.error("[MainHTML] Socket or User ID not available for joining voice channel.");
            return;
        }
        console.log(`[MainHTML] Attempting to join voice channel ${channelId}`);
        socket.emit('join_voice_channel', {channel_id: channelId});
        currentChannelId = channelId; 

        document.getElementById('join-voice-btn').style.display = 'none';
        document.getElementById('leave-voice-btn').style.display = 'inline';
        document.getElementById('mute-btn').style.display = 'inline';
        
        localStreamReady = false; // 重置状态
        inVoiceChannel = false;   // 确保在媒体绪后再设置为true

        if (typeof initializeMedia === 'function') {
            console.debug("[MainHTML] Calling initializeMedia()...");
            initializeMedia().then(() => {
                console.log("[MainHTML] initializeMedia() successful (localStream should be ready in webrtc.js).");
                localStreamReady = true; // <--- 在 localStream 真正就绪后设置
                inVoiceChannel = true;   // <--- 此时才算真正进入频道

                if (typeof setupVolumeDetection === 'function' && currentChannelId) {
                    console.debug("[MainHTML] Calling setupVolumeDetection()...");
                    setupVolumeDetection(currentChannelId); 
                }
                // 初始化媒体成功后，处理任何待处理的连接
                processPendingPeerConnections(); 
            }).catch(error => {
                console.error("[MainHTML] initializeMedia() failed:", error);
                // 处理错误，例如重置UI
                document.getElementById('join-voice-btn').style.display = 'inline';
                document.getElementById('leave-voice-btn').style.display = 'none';
                document.getElementById('mute-btn').style.display = 'none';
                localStreamReady = false;
                inVoiceChannel = false;
            });
        } else {
            console.error("[MainHTML] initializeMedia function is not defined in webrtc.js");
        }
    }
            
    function leaveVoiceChannel() {
        if (!socket) return;
        socket.emit('leave_voice_channel');
        document.getElementById('join-voice-btn').style.display = 'inline';
        document.getElementById('leave-voice-btn').style.display = 'none';
        document.getElementById('mute-btn').style.display = 'none';
        
        if (localStream) { // localStream 是 webrtc.js 中的全局变量
            localStream.getTracks().forEach(track => track.stop());
            localStream = null; // 重置 webrtc.js 中的 localStream
        }
        
        Object.keys(peerConnections).forEach(userId => { // peerConnections 是 webrtc.js 中的全局变量
            if (peerConnections[userId]) {
                peerConnections[userId].close();
                delete peerConnections[userId];
            }
        });
        
        const remoteAudioContainer = document.getElementById('remote-audio-container');
        if (remoteAudioContainer) remoteAudioContainer.innerHTML = '';
        
        localStreamReady = false; // <--- 重置状态
        inVoiceChannel = false;
        // 移除当前用户卡片的 speaking 状态 (如果需要)
        const currentUserCard = document.getElementById('voice-user-' + currentUserId);
        if (currentUserCard) currentUserCard.classList.remove('speaking');
    }

    {% if current_channel %}
        {% if current_channel.channel_type == 'text' %}
            // 文字频道脚本 (保持不变)
            // ... (socket.on('new_message', ...), sendMessage(), etc.) ...
            // 监听回车键发送消息
            document.getElementById('message-input').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    sendMessage();
                }
            });
        {% else %} // 语音频道脚本
            socket.on('user_joined_voice', function(data) {
                console.debug("[MainHTML] Event: user_joined_voice", data);
                const usersContainer = document.getElementById('users-container');
                if (!document.getElementById('voice-user-' + data.user_id)) {
                    const userCard = document.createElement('div');
                    userCard.className = 'voice-user-card';
                    userCard.id = 'voice-user-' + data.user_id;
                    const avatarPlaceholder = document.createElement('div');
                    avatarPlaceholder.className = 'user-avatar-placeholder';
                    const avatarText = document.createElement('span');
                    avatarText.textContent = data.username[0].toUpperCase();
                    avatarPlaceholder.appendChild(avatarText);
                    const usernameSpan = document.createElement('span');
                    usernameSpan.className = 'username';
                    usernameSpan.textContent = data.username;
                    const micStatusDiv = document.createElement('div');
                    micStatusDiv.className = 'mic-status';
                    micStatusDiv.id = 'mic-status-' + data.user_id;
                    userCard.appendChild(avatarPlaceholder);
                    userCard.appendChild(usernameSpan);
                    userCard.appendChild(micStatusDiv);
                    if(usersContainer) usersContainer.appendChild(userCard);
                }

                if (data.user_id == currentUserId) return; // 不处理自己

                if (inVoiceChannel && localStreamReady) { // <--- 检查 localStream 是否就绪
                    console.debug("[MainHTML] localStream is ready, directly creating peer connection for new user:", data.user_id);
                    if (typeof createPeerConnection === 'function' && typeof negotiateConnection === 'function') {
                        createPeerConnection(data.user_id); 
                        negotiateConnection(data.user_id);
                    }
                } else if (inVoiceChannel) { // 在频道中，但媒体流还未就绪
                    console.debug("[MainHTML] localStream NOT YET ready. Adding user to pending list:", data.user_id);
                    if (!pendingPeerConnectionUserIds.includes(data.user_id)) {
                        pendingPeerConnectionUserIds.push(data.user_id);
                    }
                } else {
                    console.debug("[MainHTML] Not in voice channel or localStream not ready, ignoring user_joined_voice for peer connection setup for user", data.user_id);
                }
            });
            
            socket.on('voice_channel_users', function(data) {
                console.debug("[MainHTML] Event: voice_channel_users", data);
                const usersContainer = document.getElementById('users-container');
                if(usersContainer) usersContainer.innerHTML = '';
                const currentUserIdString = String(currentUserId);
                
                let usersToConnect = [];
                data.users.forEach(user => {
                    const userCard = document.createElement('div');
                    userCard.className = 'voice-user-card';
                    userCard.id = 'voice-user-' + user.user_id;
                    const avatarPlaceholder = document.createElement('div');
                    avatarPlaceholder.className = 'user-avatar-placeholder';
                    const avatarText = document.createElement('span');
                    avatarText.textContent = user.username[0].toUpperCase();
                    avatarPlaceholder.appendChild(avatarText);
                    const usernameSpan = document.createElement('span');
                    usernameSpan.className = 'username';
                    usernameSpan.textContent = user.username;
                    const micStatusDiv = document.createElement('div');
                    micStatusDiv.className = 'mic-status';
                    micStatusDiv.id = 'mic-status-' + user.user_id;
                    userCard.appendChild(avatarPlaceholder);
                    userCard.appendChild(usernameSpan);
                    userCard.appendChild(micStatusDiv);
                    if(usersContainer) usersContainer.appendChild(userCard);

                    if (String(user.user_id) !== currentUserIdString) {
                        usersToConnect.push(user.user_id);
                    }
                });

                if (inVoiceChannel && localStreamReady) { // <--- 检查 localStream 是否就绪
                    console.debug("[MainHTML] localStream is ready, directly creating peer connections for existing users:", usersToConnect);
                    usersToConnect.forEach(userId => {
                        if (typeof createPeerConnection === 'function' && typeof negotiateConnection === 'function') {
                             createPeerConnection(userId); 
                             // negotiateConnection(userId); // 接收方通常不主动发起协商，而是等待 offer
                        }
                    });
                } else if (inVoiceChannel) { // 在频道中，但媒体流还未就绪
                    console.debug("[MainHTML] localStream NOT YET ready. Adding existing users to pending list:", usersToConnect);
                    usersToConnect.forEach(userId => {
                        if (!pendingPeerConnectionUserIds.includes(userId)) {
                            pendingPeerConnectionUserIds.push(userId);
                        }
                    });
                } else {
                     console.debug("[MainHTML] Not in voice channel or localStream not ready, ignoring voice_channel_users for peer connection setup");
                }
            });

            // 移除之前 main.html 中的 socket.on('other_user_speaking_status', ...)
            // 因为这个逻辑现在由 webrtc.js 中的 initializeWebRTC -> handleUserSpeaking 处理

        {% endif %}
    {% endif %}
    
    // 通用脚本 (保持不变)
    // ... (socket.on('user_connected', ...), socket.on('user_disconnected', ...) ...)
</script>
{% endblock %} 