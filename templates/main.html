{% extends "base.html" %}

{% block head %}
<style>
.voice-user-card {
    border: 2px solid #4F545C; /* æ·±ç°è‰²è¾¹æ¡† */
    background-color: #36393F; /* æ·±ç°è‰²èƒŒæ™¯ */
    padding: 10px;
    margin: 5px;
    border-radius: 5px;
    display: flex;
    align-items: center;
    transition: border-color 0.3s ease, background-color 0.3s ease; /* è¿‡æ¸¡æ•ˆæœ */
}

.voice-user-card.speaking {
    border-color: #7289DA; /* ç´«è‰²è¾¹æ¡† */
    background-color: #40444B; /* ç•¥æµ…çš„ç´«è‰²è°ƒèƒŒæ™¯ */
}

.voice-user-card .user-avatar-placeholder {
    width: 30px;
    height: 30px;
    background-color: #7289DA;
    color: white;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    margin-right: 10px;
    font-weight: bold;
}

.voice-user-card .username {
    color: #FFFFFF;
}

.voice-user-card .mic-status {
    margin-left: auto; /* å°†éº¦å…‹é£çŠ¶æ€æ¨åˆ°å³ä¾§ */
    /* å¯ä»¥åœ¨è¿™é‡Œæ·»åŠ å›¾æ ‡ç­‰ */
}
</style>
<!-- WebRTCä»£ç ï¼Œåªåœ¨éœ€è¦æ—¶åŠ è½½ -->
{% if current_channel and current_channel.channel_type == 'voice' %}
<script src="{{ url_for('static', filename='js/webrtc.js') }}"></script>
{% endif %}
{% endblock %}

{% block content %}
<!-- å·¦ä¾§è¾¹æ ï¼šé¢‘é“åˆ—è¡¨ -->
<div class="sidebar">
    <div class="user-avatar-container" onclick="location.href='{{ url_for('settings') }}';">
        {% if current_user.avatar_url %}
            <img src="{{ current_user.avatar_url }}" alt="User Avatar" class="avatar-image">
        {% else %}
            <div class="avatar-placeholder">
                <span class="avatar-text">{{ current_user.username[0].upper() }}</span>
            </div>
        {% endif %}
        <span class="username-display">{{ current_user.username }}</span>
    </div>
    
    <!-- æ–‡å­—é¢‘é“ -->
    <div class="channel-list">
        <div class="channel-header">æ–‡å­—é¢‘é“</div>
        {% for channel in text_channels %}
        <div class="channel {% if current_channel and current_channel.id == channel.id %}current-channel{% endif %}" 
             onclick="location.href='{{ url_for('channel', channel_id=channel.id) }}';">
            {% if channel.is_private %}ğŸ”’ {% endif %}# {{ channel.name }}
        </div>
        {% endfor %}
    </div>
    
    <!-- è¯­éŸ³é¢‘é“ -->
    <div class="channel-list">
        <div class="channel-header">è¯­éŸ³é¢‘é“</div>
        {% for channel in voice_channels %}
        <div class="channel {% if current_channel and current_channel.id == channel.id %}current-channel{% endif %}" 
             onclick="location.href='{{ url_for('channel', channel_id=channel.id) }}';">
            {% if channel.is_private %}ğŸ”’ {% endif %}ğŸ”Š {{ channel.name }}
        </div>
        {% endfor %}
    </div>
    
    {% if current_user.is_admin %}
    <div style="margin-top: 20px;">
        <button onclick="location.href='{{ url_for('create_channel') }}';" 
                style="width: 100%; padding: 8px; background-color: #7289da; color: white; border: none; border-radius: 3px; cursor: pointer;">
            åˆ›å»ºæ–°é¢‘é“
        </button>
    </div>
    {% endif %}
    
    <div style="margin-top: 10px;">
        <button onclick="location.href='{{ url_for('logout') }}';" 
                style="width: 100%; padding: 8px; background-color: #f04747; color: white; border: none; border-radius: 3px; cursor: pointer;">
            ç™»å‡º
        </button>
    </div>
</div>

<!-- ä¸»å†…å®¹åŒº -->
<div class="main-content">
    {% if current_channel %}
        {% if current_channel.channel_type == 'text' %}
            <!-- æ–‡å­—é¢‘é“å†…å®¹ -->
            <div class="chat-container" id="chat-container">
                {% if messages %}
                    {% for message in messages %}
                    <div class="message" id="message-{{ message.id }}">
                        <div class="message-avatar">
                            {% if message.user.avatar_url %}
                                <img src="{{ message.user.avatar_url }}" alt="{{ message.user.username }} avatar" class="avatar-image-sm">
                            {% else %}
                                <div class="avatar-placeholder-sm">
                                    <span class="avatar-text-sm">{{ message.user.username[0].upper() }}</span>
                                </div>
                            {% endif %}
                        </div>
                        <div class="message-content-container">
                            <span class="username">{{ message.user.username }}</span>
                            <span class="timestamp">{{ message.timestamp.strftime('%H:%M:%S') }}</span>
                            <div class="content">{{ message.content }}</div>
                        </div>
                    </div>
                    {% endfor %}
                {% else %}
                    <div style="text-align: center; margin-top: 20px; color: #8e9297;">
                        æ²¡æœ‰æ¶ˆæ¯ã€‚å‘é€ç¬¬ä¸€æ¡æ¶ˆæ¯å¼€å§‹èŠå¤©å§ï¼
                    </div>
                {% endif %}
            </div>
            <div class="message-input">
                <input type="text" id="message-input" placeholder="å‘é€æ¶ˆæ¯åˆ° #{{ current_channel.name }}">
                <button onclick="sendMessage()">å‘é€</button>
            </div>
        {% else %}
            <!-- è¯­éŸ³é¢‘é“å†…å®¹ -->
            <div class="chat-container">
                <div style="text-align: center; margin: 20px 0;">
                    <h2>è¯­éŸ³é¢‘é“: {{ current_channel.name }}</h2>
                </div>
                
                <div id="users-container">
                    {% if active_users %}
                        {% for session in active_users %}
                        <div class="voice-user-card" id="voice-user-{{ session.user.id }}">
                            <div class="user-avatar-placeholder">
                                <span>{{ session.user.username[0].upper() }}</span>
                            </div>
                            <span class="username">{{ session.user.username }}</span>
                            <div class="mic-status" id="mic-status-{{ session.user.id }}">
                                <!-- éº¦å…‹é£çŠ¶æ€æŒ‡ç¤º (ä¾‹å¦‚å›¾æ ‡) å°†é€šè¿‡JSæ›´æ–° -->
                            </div>
                        </div>
                        {% endfor %}
                    {% else %}
                        <div style="text-align: center; color: #8e9297;">
                            æ²¡æœ‰äººåœ¨æ­¤é¢‘é“ä¸­ã€‚
                        </div>
                    {% endif %}
                </div>
                
                <!-- ç”¨äºè¯­éŸ³è¾“å‡ºçš„éšè—éŸ³é¢‘å…ƒç´  -->
                <div id="remote-audio-container" style="display: none;"></div>
            </div>
            
            <!-- è¯­éŸ³æ§åˆ¶ -->
            <div class="voice-controls">
                <button id="join-voice-btn" onclick="joinVoiceChannel({{ current_channel.id if current_channel else 'null' }})">åŠ å…¥è¯­éŸ³</button>
                <button id="leave-voice-btn" onclick="leaveVoiceChannel()" style="display: none;">ç¦»å¼€è¯­éŸ³</button>
                <button id="mute-btn" onclick="toggleMute()" class="mute" style="display: none;">é™éŸ³</button>
            </div>
        {% endif %}
    {% else %}
        <!-- æœªé€‰æ‹©é¢‘é“æ—¶çš„é»˜è®¤å†…å®¹ -->
        <div style="display: flex; justify-content: center; align-items: center; height: 100%;">
            <div style="text-align: center; color: #8e9297;">
                <h2>æ¬¢è¿ä½¿ç”¨è¯­éŸ³èŠå¤©æœåŠ¡</h2>
                <p>è¯·ä»å·¦ä¾§é€‰æ‹©ä¸€ä¸ªé¢‘é“å¼€å§‹èŠå¤©</p>
            </div>
        </div>
    {% endif %}
</div>

<!-- å³ä¾§è¾¹æ ï¼šç”¨æˆ·åˆ—è¡¨ -->
<div class="user-list">
    <div class="channel-header">åœ¨çº¿ç”¨æˆ·</div>
    <div id="online-users">
        <!-- ç”¨æˆ·ä¼šé€šè¿‡WebSocketåŠ¨æ€æ·»åŠ  -->
        <div class="user">
            <div class="user-status online"></div>
            <span>{{ current_user.username }} (ä½ )</span>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
    const socket = io(); // Socket.IO å®¢æˆ·ç«¯åˆå§‹åŒ–
    let currentChannelId = null; // ç”¨äºå­˜å‚¨å½“å‰é¢‘é“ID
    let currentUserId = null;    // ç”¨äºå­˜å‚¨å½“å‰ç”¨æˆ·ID

    {% if current_channel %}
        currentChannelId = {{ current_channel.id }};
    {% endif %}
    {% if current_user %}
        currentUserId = {{ current_user.id }};
    {% endif %}

    // å½“socketè¿æ¥æˆåŠŸå¹¶ä¸”è·å–åˆ°ç”¨æˆ·IDåï¼Œåˆå§‹åŒ–WebRTC
    socket.on('connect', function() {
        if (currentUserId && typeof initializeWebRTC === 'function') {
            initializeWebRTC(socket, currentUserId);
        }
        
        {% if current_channel %}
            {% if current_channel.channel_type == 'text' %}
                // æ–‡å­—é¢‘é“åŠ å…¥é€»è¾‘
                socket.emit('join_text_channel', {channel_id: currentChannelId});
                const chatContainer = document.getElementById('chat-container');
                if (chatContainer) chatContainer.scrollTop = chatContainer.scrollHeight;
            {% else %}
                // è¯­éŸ³é¢‘é“ç‰¹æœ‰é€»è¾‘å¯ä»¥åœ¨ joinVoiceChannel ä¸­å¤„ç†ï¼Œ
                // æˆ–è€…åœ¨è¿™é‡Œè¿›è¡Œä¸€äº›åˆå§‹è®¾ç½®ï¼ˆå¦‚æœéœ€è¦çš„è¯ï¼‰
            {% endif %}
        {% endif %}
    });

    {% if current_channel and current_channel.channel_type == 'voice' %}
        // ç§»é™¤ä¹‹å‰åœ¨ main.html ä¸­æ·»åŠ çš„è¯­éŸ³æ£€æµ‹é€»è¾‘
        // let localAudioAnalyser = null;
        // let localAudioDataArray = null;
        // const SPEAKING_THRESHOLD = 5;
        // let currentUserSpeaking = false;
        // let speakingDetectionInterval = null;

        // function setupLocalMicrophoneDetection() { ... } // ç§»é™¤
        // function detectCurrentUserSpeaking() { ... } // ç§»é™¤
    {% endif %}

    // å…¨å±€çš„ inVoiceChannel çŠ¶æ€
    let inVoiceChannel = false;
    let localStreamReady = false; // <--- æ–°å¢æ ‡å¿—ä½
    let pendingPeerConnectionUserIds = []; // <--- å­˜å‚¨ç­‰å¾…å¤„ç†çš„ç”¨æˆ·ID
            
    function processPendingPeerConnections() {
        if (localStreamReady && pendingPeerConnectionUserIds.length > 0) {
            console.debug("[MainHTML] Processing pending peer connections for users:", pendingPeerConnectionUserIds);
            pendingPeerConnectionUserIds.forEach(userId => {
                if (userId != currentUserId && typeof createPeerConnection === 'function' && typeof negotiateConnection === 'function') {
                    console.debug("[MainHTML] Creating peer connection for pending user:", userId);
                    createPeerConnection(userId); 
                    negotiateConnection(userId);
                }
            });
            pendingPeerConnectionUserIds = []; // æ¸…ç©ºé˜Ÿåˆ—
        }
    }

    function joinVoiceChannel(channelId) {
        if (!socket || !currentUserId) {
            console.error("[MainHTML] Socket or User ID not available for joining voice channel.");
            return;
        }
        console.log(`[MainHTML] Attempting to join voice channel ${channelId}`);
        socket.emit('join_voice_channel', {channel_id: channelId});
        currentChannelId = channelId; 

        document.getElementById('join-voice-btn').style.display = 'none';
        document.getElementById('leave-voice-btn').style.display = 'inline';
        document.getElementById('mute-btn').style.display = 'inline';
        
        localStreamReady = false; // é‡ç½®çŠ¶æ€
        inVoiceChannel = false;   // ç¡®ä¿åœ¨åª’ä½“ç»ªåå†è®¾ç½®ä¸ºtrue

        if (typeof initializeMedia === 'function') {
            console.debug("[MainHTML] Calling initializeMedia()...");
            initializeMedia().then(() => {
                console.log("[MainHTML] initializeMedia() successful (localStream should be ready in webrtc.js).");
                localStreamReady = true; // <--- åœ¨ localStream çœŸæ­£å°±ç»ªåè®¾ç½®
                inVoiceChannel = true;   // <--- æ­¤æ—¶æ‰ç®—çœŸæ­£è¿›å…¥é¢‘é“

                if (typeof setupVolumeDetection === 'function' && currentChannelId) {
                    console.debug("[MainHTML] Calling setupVolumeDetection()...");
                    setupVolumeDetection(currentChannelId); 
                }
                // åˆå§‹åŒ–åª’ä½“æˆåŠŸåï¼Œå¤„ç†ä»»ä½•å¾…å¤„ç†çš„è¿æ¥
                processPendingPeerConnections(); 
            }).catch(error => {
                console.error("[MainHTML] initializeMedia() failed:", error);
                // å¤„ç†é”™è¯¯ï¼Œä¾‹å¦‚é‡ç½®UI
                document.getElementById('join-voice-btn').style.display = 'inline';
                document.getElementById('leave-voice-btn').style.display = 'none';
                document.getElementById('mute-btn').style.display = 'none';
                localStreamReady = false;
                inVoiceChannel = false;
            });
        } else {
            console.error("[MainHTML] initializeMedia function is not defined in webrtc.js");
        }
    }
            
    function leaveVoiceChannel() {
        if (!socket) return;
        socket.emit('leave_voice_channel');
        document.getElementById('join-voice-btn').style.display = 'inline';
        document.getElementById('leave-voice-btn').style.display = 'none';
        document.getElementById('mute-btn').style.display = 'none';
        
        if (localStream) { // localStream æ˜¯ webrtc.js ä¸­çš„å…¨å±€å˜é‡
            localStream.getTracks().forEach(track => track.stop());
            localStream = null; // é‡ç½® webrtc.js ä¸­çš„ localStream
        }
        
        Object.keys(peerConnections).forEach(userId => { // peerConnections æ˜¯ webrtc.js ä¸­çš„å…¨å±€å˜é‡
            if (peerConnections[userId]) {
                peerConnections[userId].close();
                delete peerConnections[userId];
            }
        });
        
        const remoteAudioContainer = document.getElementById('remote-audio-container');
        if (remoteAudioContainer) remoteAudioContainer.innerHTML = '';
        
        localStreamReady = false; // <--- é‡ç½®çŠ¶æ€
        inVoiceChannel = false;
        // ç§»é™¤å½“å‰ç”¨æˆ·å¡ç‰‡çš„ speaking çŠ¶æ€ (å¦‚æœéœ€è¦)
        const currentUserCard = document.getElementById('voice-user-' + currentUserId);
        if (currentUserCard) currentUserCard.classList.remove('speaking');
    }

    {% if current_channel %}
        {% if current_channel.channel_type == 'text' %}
            // æ–‡å­—é¢‘é“è„šæœ¬ (ä¿æŒä¸å˜)
            // ... (socket.on('new_message', ...), sendMessage(), etc.) ...
            // ç›‘å¬å›è½¦é”®å‘é€æ¶ˆæ¯
            document.getElementById('message-input').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    sendMessage();
                }
            });
        {% else %} // è¯­éŸ³é¢‘é“è„šæœ¬
            socket.on('user_joined_voice', function(data) {
                console.debug("[MainHTML] Event: user_joined_voice", data);
                const usersContainer = document.getElementById('users-container');
                if (!document.getElementById('voice-user-' + data.user_id)) {
                    const userCard = document.createElement('div');
                    userCard.className = 'voice-user-card';
                    userCard.id = 'voice-user-' + data.user_id;
                    const avatarPlaceholder = document.createElement('div');
                    avatarPlaceholder.className = 'user-avatar-placeholder';
                    const avatarText = document.createElement('span');
                    avatarText.textContent = data.username[0].toUpperCase();
                    avatarPlaceholder.appendChild(avatarText);
                    const usernameSpan = document.createElement('span');
                    usernameSpan.className = 'username';
                    usernameSpan.textContent = data.username;
                    const micStatusDiv = document.createElement('div');
                    micStatusDiv.className = 'mic-status';
                    micStatusDiv.id = 'mic-status-' + data.user_id;
                    userCard.appendChild(avatarPlaceholder);
                    userCard.appendChild(usernameSpan);
                    userCard.appendChild(micStatusDiv);
                    if(usersContainer) usersContainer.appendChild(userCard);
                }

                if (data.user_id == currentUserId) return; // ä¸å¤„ç†è‡ªå·±

                if (inVoiceChannel && localStreamReady) { // <--- æ£€æŸ¥ localStream æ˜¯å¦å°±ç»ª
                    console.debug("[MainHTML] localStream is ready, directly creating peer connection for new user:", data.user_id);
                    if (typeof createPeerConnection === 'function' && typeof negotiateConnection === 'function') {
                        createPeerConnection(data.user_id); 
                        negotiateConnection(data.user_id);
                    }
                } else if (inVoiceChannel) { // åœ¨é¢‘é“ä¸­ï¼Œä½†åª’ä½“æµè¿˜æœªå°±ç»ª
                    console.debug("[MainHTML] localStream NOT YET ready. Adding user to pending list:", data.user_id);
                    if (!pendingPeerConnectionUserIds.includes(data.user_id)) {
                        pendingPeerConnectionUserIds.push(data.user_id);
                    }
                } else {
                    console.debug("[MainHTML] Not in voice channel or localStream not ready, ignoring user_joined_voice for peer connection setup for user", data.user_id);
                }
            });
            
            socket.on('voice_channel_users', function(data) {
                console.debug("[MainHTML] Event: voice_channel_users", data);
                const usersContainer = document.getElementById('users-container');
                if(usersContainer) usersContainer.innerHTML = '';
                const currentUserIdString = String(currentUserId);
                
                let usersToConnect = [];
                data.users.forEach(user => {
                    const userCard = document.createElement('div');
                    userCard.className = 'voice-user-card';
                    userCard.id = 'voice-user-' + user.user_id;
                    const avatarPlaceholder = document.createElement('div');
                    avatarPlaceholder.className = 'user-avatar-placeholder';
                    const avatarText = document.createElement('span');
                    avatarText.textContent = user.username[0].toUpperCase();
                    avatarPlaceholder.appendChild(avatarText);
                    const usernameSpan = document.createElement('span');
                    usernameSpan.className = 'username';
                    usernameSpan.textContent = user.username;
                    const micStatusDiv = document.createElement('div');
                    micStatusDiv.className = 'mic-status';
                    micStatusDiv.id = 'mic-status-' + user.user_id;
                    userCard.appendChild(avatarPlaceholder);
                    userCard.appendChild(usernameSpan);
                    userCard.appendChild(micStatusDiv);
                    if(usersContainer) usersContainer.appendChild(userCard);

                    if (String(user.user_id) !== currentUserIdString) {
                        usersToConnect.push(user.user_id);
                    }
                });

                if (inVoiceChannel && localStreamReady) { // <--- æ£€æŸ¥ localStream æ˜¯å¦å°±ç»ª
                    console.debug("[MainHTML] localStream is ready, directly creating peer connections for existing users:", usersToConnect);
                    usersToConnect.forEach(userId => {
                        if (typeof createPeerConnection === 'function' && typeof negotiateConnection === 'function') {
                             createPeerConnection(userId); 
                             // negotiateConnection(userId); // æ¥æ”¶æ–¹é€šå¸¸ä¸ä¸»åŠ¨å‘èµ·åå•†ï¼Œè€Œæ˜¯ç­‰å¾… offer
                        }
                    });
                } else if (inVoiceChannel) { // åœ¨é¢‘é“ä¸­ï¼Œä½†åª’ä½“æµè¿˜æœªå°±ç»ª
                    console.debug("[MainHTML] localStream NOT YET ready. Adding existing users to pending list:", usersToConnect);
                    usersToConnect.forEach(userId => {
                        if (!pendingPeerConnectionUserIds.includes(userId)) {
                            pendingPeerConnectionUserIds.push(userId);
                        }
                    });
                } else {
                     console.debug("[MainHTML] Not in voice channel or localStream not ready, ignoring voice_channel_users for peer connection setup");
                }
            });

            // ç§»é™¤ä¹‹å‰ main.html ä¸­çš„ socket.on('other_user_speaking_status', ...)
            // å› ä¸ºè¿™ä¸ªé€»è¾‘ç°åœ¨ç”± webrtc.js ä¸­çš„ initializeWebRTC -> handleUserSpeaking å¤„ç†

        {% endif %}
    {% endif %}
    
    // é€šç”¨è„šæœ¬ (ä¿æŒä¸å˜)
    // ... (socket.on('user_connected', ...), socket.on('user_disconnected', ...) ...)
</script>
{% endblock %} 